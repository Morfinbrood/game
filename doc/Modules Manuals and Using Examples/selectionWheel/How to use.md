Модуль SelectionWheel это по сути визуалиция попертей входного объекта, с последующим ретурном выбранного проперти объекта. В планах даже есть возможность углубляться в эти свойства пока не достигнешь заданного уровня или последнего. При этом можно кастомизировать, что именно будет выдаваться в окне инфо при достижении заданных свойств, и какие из этих свойств будут выводится(перечисленные), а какие нет. Именно это мы и продемонстрировали использовав этот модуль не только для выбора кастов, но и игрового меню.

В example1 приведён пример как его можно использовать для обычных меню. Узнавая на какую именно кнопку юзер нажал. И отображая заданное инфо при наведении на кнопку.

Переключаться между кнопками можно стрелками вправо-влево. 

Отображении инфо появляется при наведении на одну из кнопок.

Первоочередная задача модуля это всё же визуализация пропертей входного объекта и ретурн выбранного. Использование его для GameMenu всё же не самый рациональный выбор, это сделано просто для примера.

На данный момент css во 2-ом примере заложено ограничение на отображение не более 6 пропертей, все остальные будут друг друга перекрывать вне области колеса.

В 1-ом примере они не будут накладываться, но могут уйти вниз экрана. Поэтому рекомендуемое колличество пропертей 6, в остальных случаях нужно дорабатывать оба стиля или полностью свой применять.

ВАЖНО!! модуль возвращает new Promise, и пока вы не сделате выбор или не нажмёте back этот промис находится в режиме pending. Это меню задумано так, чтобы вызывая через async await new SelectionWheel(...) вы тем самым останавливали выполнение кода и сделал выбор продолжали.

После того как модуль возвращает значение он удаляется из дома. И при след вызове заново строится через createelement.

Разберём 1 пример:
const infoOutputScheme = { info: 'this is addition text' };
В этой схеме вы задаёте какие подпроперти вы хотите чтобы отображались при наведении на проверти. Например:
У скармливаемого объекта
	const menuObj = {
		'start new game': { nameButton: 'startNewGame', info: 'Press button to start game' },
		'music on/off': { nameButton: 'musicOn_Off', info: 'Press for on or off music' },
		'volume +': { nameButton: 'increaseVol', info: 'Press for increase volume' },
		'volume -': { nameButton: 'decreaseVol', info: 'Press for decrease volume' },
		'scoreboard': { nameButton: 'scoreboard', info: 'Press for display scoreboard' }
	};

У его проперти 'start new game' , есть проперти nameButton и info
Мы хотим, чтобы при наведении на эту кнопку у нав в инфоПоле выводилось, только проперти info и его текст. Тогда мы задаём const infoOutputScheme = { info: '' };
Если мы хотим, чтобы появилось какое-то пояснение, что именно мы отображаем в инфоПоле мы задаём туда текст const infoOutputScheme = { info: 'this is addition text' };
Этот текст это синяя надпись на примере, а само значение info: Press button to start game'

Сделано это для того, чтобы отображать имено то что мы хотим, не отображая какие-то вспомогательные подпроперти, как то пути на картинки иконок. В нашем примере это рандомные проперти с рандомными значениями.

Имена кнопок будут браться из названия самих пропертей.

При выборе одного из пропертей нам будет возвращён один из объектов:
{ nameButton: 'startNewGame', info: 'Press button to start game' }
или 
{ nameButton: 'musicOn_Off', info: 'Press for on or off music' }
или любой другой который мы веберем.

В именно этот объект будет результатом всего промиса, где мы уже смотрим на что именно человек нажал в swith case.


Разберём 2 пример:
const infoOutputScheme = { damage: 'Damage/heal', manacost: 'Difficulty' };
Мы хотим, чтобы отобразились только значения пропертей damage и manacost с соотвествующим пояснительным тектом.
У скармливаемого объекта
	const object = {
		fireball: { damage: 10, manacost: 10, icon_path: 'img/icons/fireball.jpg' },
		attack: { damage: 340, manacost: 564, icon_path: 'img/icons/attack.jpg' },
		slash: { damage: 34, manacost: 133, icon_path: 'img/icons/slash.jpg' },
		kick: { damage: 576, manacost: 1, icon_path: 'img/icons/kick.jpg' },
		iceBolt: { damage: 2, manacost: 0, icon_path: 'img/icons/iceBolt.jpg' },
	};

Стоит отменить, что модуль может отрисоывать иконки на кнопках, если у нас будет свойство icon_path: с путём на иконку.

Результатом выбора здесь также будут один из объектов.
{ damage: 10, manacost: 10, icon_path: 'img/icons/fireball.jpg' } например.

и с учётом этого результата мы уже работаем дальше.

Основная цель модуля это получение этого подобъекта.






